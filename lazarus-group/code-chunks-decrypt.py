# coding=utf-8
"""
IdaPython script for CRat code chunks decryption.
Tested on IDA 7.5 with Python3
"""

import ida_kernwin
import ida_idaapi
import ida_bytes
import idc

__author__ = "Vladyslav Bahlai"

PATTERN = "C7 05 ?? ?? ?? ?? ?? ?? ?? ?? C7 05 ?? ?? ?? ?? ?? ?? ?? ?? "\
          "C7 05 ?? ?? ?? ?? ?? ?? ?? ?? C7 05 ?? ?? ?? ?? ?? ?? ?? ??"

def _pattern_len(pattern):
    """
    Returns pattern length in bytes
    """
    return len(pattern) // 3 + 1 if len(pattern) % 3 else 0

def fill_with_nops(start, stop):
    for p in range(start, stop):
        ida_bytes.patch_byte(p, 0x90)
        idc.create_insn(p)

    idc.create_insn(stop)

def patch():
    ea = idc.find_binary(0, idc.SEARCH_NEXT | idc.SEARCH_DOWN | idc.SEARCH_CASE, PATTERN)

    start_addr = None
    pattern_len = _pattern_len(PATTERN)

    while not (ea == ida_idaapi.BADADDR or idc.get_segm_name(ea) != '.text'):
        # If we don't have start address saved, save it and search for the next pattern match
        if not start_addr:
            start_addr = ea

        # If start address was saved before, we got end address. It's time to patch
        else:
            # Remove marker patterns to prevent re-encryption on the next script run
            fill_with_nops(start_addr, start_addr + pattern_len)
            fill_with_nops(ea, ea + pattern_len)

            # Decrypt the code between markers
            for addr in range(start_addr + pattern_len, ea):
                ida_bytes.patch_byte(addr, ~idc.get_wide_byte(addr))

            print('[0x%08X..0x%08X] Region patched' % (start_addr, ea + pattern_len))

            start_addr = None

        ea = idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN | idc.SEARCH_CASE, PATTERN)

    print('[PATCHING FINISHED]')

patch()
