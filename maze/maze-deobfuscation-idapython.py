# coding=utf-8
"""
IdaPython script for Maze ransomware deobfuscation.
Tested on IDA 7.5 with Python3
"""

import ida_idaapi
import ida_bytes
import idc

__author__ = "Vladyslav Bahlai"
__email__ = "baglai.vlad@gmail.com"


def fill_with_nops(start, stop):
    for p in range(start, stop):
        ida_bytes.patch_byte(p, 0x90)
        idc.create_insn(p)

    idc.create_insn(stop)


def _pattern_len(pattern):
    return len(pattern) // 3 + 1 if len(pattern) % 3 else 0


def resolve_obf_calls(ea):
    next_instr_addr = idc.get_wide_dword(ea + 1)

    first_jmp_target = (ea + idc.get_wide_dword(ea + 0x7) + 0xB) & 0xFFFFFFFF
    second_jmp_target = (ea + idc.get_wide_dword(ea + 0xD) + 0x11) & 0xFFFFFFFF

    if first_jmp_target != second_jmp_target:
        return

    call_param = (first_jmp_target - ea - 5) & 0xFFFFFFFF

    # Now we can replace all code till next instruction's address with NOPs
    fill_with_nops(ea, next_instr_addr)

    # Insert CALL
    ida_bytes.patch_byte(ea, 0xE8)                      # CALL
    ida_bytes.patch_dword(ea + 1, call_param)
    idc.create_insn(ea)

    return True


def cleanup_resolveapi_calls(ea):
    delta = 0 if idc.get_wide_byte(ea) == 0x6A else 3

    intermediate_call_target = idc.get_wide_dword(ea + 8 + delta)
    if intermediate_call_target > 0x40:
        return

    # Check if we got library name
    if idc.get_wide_dword(ea + intermediate_call_target + 8 + delta) != 0x006c6c64:   # "dll\x00"
        return

    # Check if we got enough space for patching
    if idc.get_wide_dword(ea + intermediate_call_target + 0x11 + delta) != 0x90909090 or \
    idc.get_wide_byte(ea + intermediate_call_target + 0x15 + delta) != 0x90:
        return

    idc.patch_byte(ea + 7 + delta, 0xEB)
    idc.patch_byte(ea + 8 + delta, intermediate_call_target + 3)
    fill_with_nops(ea + 9 + delta, ea + 0xC + delta)
    idc.create_insn(ea + 7 + delta)

    # Now we need to pass module name parameter through stack
    resolve_api_call_param = idc.get_wide_dword(ea + intermediate_call_target + 0xD + delta)
    resolve_api_call_param = resolve_api_call_param - 5     # offset due to inserted PUSH command

    # Insert new PUSH command
    idc.patch_byte(ea + intermediate_call_target + 0xC + delta, 0x68)
    idc.patch_dword(ea + intermediate_call_target + 0xD + delta, ea + 0xC + delta)
    idc.create_insn(ea + intermediate_call_target + 0xC + delta)

    # Restore call ResolveApi
    idc.patch_byte(ea + intermediate_call_target + 0x11 + delta, 0xE8)
    idc.patch_dword(ea + intermediate_call_target + 0x12 + delta, resolve_api_call_param)
    idc.create_insn(ea + intermediate_call_target + 0x11 + delta)
    
    return True


def resolve_calls_through_register(ea):
    next_instr_addr = idc.get_wide_dword(ea + 1)

    # Check if that's just a parameter passing through stack
    if ea & 0xFFFF0000 != next_instr_addr & 0xFFFF0000:
        return

    if next_instr_addr - ea > 0x100:
        return

    if idc.get_wide_byte(ea + 6) & 0xF0 in [0x20, 0xE0]:
        call_param = 0x9000 + idc.get_wide_byte(ea + 6) ^ 0x30
    else:
        call_param = idc.get_wide_word(ea + 6) ^ 0x30

    fill_with_nops(ea, next_instr_addr)
    idc.patch_byte(ea, 0xFF)
    idc.patch_word(ea + 1, call_param)
    idc.create_insn(ea)

    return True


def deobfuscate_rets(ea):
    if idc.get_wide_byte(ea) == 0x83:
        fill_with_nops(ea, ea + 7)
    else:
        fill_with_nops(ea, ea + 8)

    idc.patch_byte(ea, 0xC3)
    idc.create_insn(ea)

    return True


def simplify_jumps(ea):
    # If we got long first conditional jump
    if idc.get_wide_byte(ea) == 0x0F:
        alternative_jmp_cmd = idc.get_wide_byte(ea + 1) ^ 1
        interm_jmp_offt = 6
    else:
        alternative_jmp_cmd = idc.get_wide_byte(ea) ^ 0xF1
        interm_jmp_offt = 2

    # Get intermediate jump's value
    if idc.get_wide_byte(ea + interm_jmp_offt) == 0x0F:
        interm_jmp_param = idc.get_wide_dword(ea + interm_jmp_offt + 2)
        final_jmp_addr = ea + interm_jmp_param + interm_jmp_offt + 6
    else:
        interm_jmp_param = idc.get_wide_byte(ea + interm_jmp_offt + 1)
        final_jmp_addr = ea + interm_jmp_param + interm_jmp_offt + 2

    # Check the last conditional jump

    # 75 ?? ... 0F 85 ?? ?? ?? ??
    if idc.get_wide_byte(final_jmp_addr) == 0x0F and \
       idc.get_wide_byte(final_jmp_addr + 1) == alternative_jmp_cmd:
        final_jmp_param = idc.get_wide_dword(final_jmp_addr + 2)
        final_jmp_target = (final_jmp_addr + final_jmp_param + 6) & 0xFFFFFFFF

    # 75 ?? ... 75 ??
    elif idc.get_wide_byte(final_jmp_addr) ^ 0xF0 == alternative_jmp_cmd:
        final_jmp_param = idc.get_wide_byte(final_jmp_addr + 1)
        final_jmp_target = (final_jmp_addr + final_jmp_param + 2) & 0xFFFFFFFF

    # Make a little cleanup: remove garbage code
    elif interm_jmp_param < 0x10:
        fill_with_nops(ea + interm_jmp_offt, final_jmp_addr)
        return True

    else:
        return

    if final_jmp_target - ea < 0xFF:
        fill_with_nops(ea + interm_jmp_offt, final_jmp_target)
    else:
        fill_with_nops(ea + interm_jmp_offt, final_jmp_addr + 6)

    # Restore seconds jump
    idc.patch_byte(ea + interm_jmp_offt, 0x0F)
    idc.patch_byte(ea + interm_jmp_offt + 1, alternative_jmp_cmd)
    idc.patch_dword(ea + interm_jmp_offt + 2, final_jmp_target - (ea + interm_jmp_offt) - 6)
    idc.create_insn(ea + interm_jmp_offt)

    return True


# EBCB7F550D19227E554F83A65EA422D9163AB6E437F30AEC4D71FD12F0D26AFB
PATCH_DATA = [
    (
        [
            # .text:00422F6B 0F 84 AF E5 FD FF                             jz      loc_401520
            # .text:00422F71 75 04                                         jnz     short loc_422F77
            # ...
            # .text:00422F77 75 10                                         jnz     short loc_422F89

            # .text:00401CB0 0F 84 AD 63 03 00                             jz      sub_438063
            # .text:00401CB6 75 04                                         jnz     short loc_401CBC
            # ...
            # .text:00401CBC 0F 85 A1 63 03 00                             jnz     sub_438063
            "0F 84 ?? ?? ?? ?? 75 ??",

            # .text:00422F89 0F 85 80 00 00 00                             jnz     loc_42300F
            # .text:00422F8F 74 04                                         jz      short loc_422F95
            # ...
            # .text:00422F95 74 0A                                         jz      short loc_422FA1
            "0F 85 ?? ?? ?? ?? 74 ??",

            # .text:00401FC4 74 2A                                         jz      short loc_401FF0
            # .text:00401FC6 75 04                                         jnz     short loc_401FCC
            # ...
            # .text:00401FCC 75 0A                                         jnz     short loc_401FD8
            "74 ?? 75 ??",

            "75 ?? 74 ??",

            # .text:00422F6B 0F 84 AF E5 FD FF                             jz      ResolveApi
            # .text:00422F71 0F 85 98 00 00 00                             jnz     loc_42300F
            # ...
            # .text:0042300F 0F 85 0B E5 FD FF                             jnz     ResolveApi
            "0F 84 ?? ?? ?? ?? 0F 85 ?? ?? ?? ??",

            "0F 85 ?? ?? ?? ?? 0F 84 ?? ?? ?? ??"
        ],
        simplify_jumps
    ),
    (
        [
            # .text:00422F66 68 28 31 42 00                                push    offset loc_423128
            # .text:00422F6B 0F 84 AF E5 FD FF                             jz      loc_401520
            # .text:00422F71 0F 85 A9 E5 FD FF                             jnz     loc_401520
            "68 ?? ?? ?? ?? 0F 84 ?? ?? ?? ?? 0F 85 ?? ?? ?? ??",

            "68 ?? ?? ?? ?? 0F 85 ?? ?? ?? ?? 0F 84 ?? ?? ?? ??"
        ],
        resolve_obf_calls
    ),
    (
        [
            # .text:00435E2C 004 68 C6 11 00 00                                push    11C6h           ; XorModifier
            # .text:00435E31 008 68 7A 14 8F 2F                                push    2F8F147Ah       ; ApiHash
            # .text:00435E36 00C E8 0D 00 00 00                                call    loc_435E48
            # .text:00435E3B 000 6B 65 72 6E 65 6C 33 32 2E 64+aKernel32Dll_0  db 'kernel32.dll',0
            # .text:00435E48 000 E8 D3 B6 FC FF                                call    ResolveApi
            "68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8 ?? ?? ?? ??",

            # .text:0043492C 6A 7C                                             push    7Ch ; '|'       ; XorModifier
            # .text:0043492E 68 17 04 F7 15                                    push    15F70417h       ; ApiHash
            # .text:00434933 E8 0D 00 00 00                                    call    loc_434945
            # .text:00434938 6B 65 72 6E 65 6C 33 32 2E 64+    aKernel32Dll_28 db 'kernel32.dll',0
            # .text:00434945 E8 D6 CB FC FF                                    call    ResolveApi
            "6A ?? 68 ?? ?? ?? ?? E8 ?? ?? ?? ??"
        ],
        cleanup_resolveapi_calls
    ),
    (
        [
            # .text:00428DD7 68 E3 8D 42 00                                push    offset unk_428DE3
            # .text:00428DDC FF 60 0C                                      jmp     dword ptr [eax+0Ch]
            "68 ?? ?? ?? ?? FF 60 ??",
            "68 ?? ?? ?? ?? FF 61 ??",
            "68 ?? ?? ?? ?? FF 62 ??",
            "68 ?? ?? ?? ?? FF 63 ??",
            "68 ?? ?? ?? ?? FF 64 ??",
            "68 ?? ?? ?? ?? FF 65 ??",
            "68 ?? ?? ?? ?? FF 66 ??",
            "68 ?? ?? ?? ?? FF 67 ??",

            # .text:00435F9B 01C 68 B6 5F 43 00                            push    offset loc_435FB6
            # .text:00435FA0 020 FF E7                                     jmp     edi
            "68 ?? ?? ?? ?? FF E0",
            "68 ?? ?? ?? ?? FF E1",
            "68 ?? ?? ?? ?? FF E2",
            "68 ?? ?? ?? ?? FF E3",
            "68 ?? ?? ?? ?? FF E4",
            "68 ?? ?? ?? ?? FF E5",
            "68 ?? ?? ?? ?? FF E6",
            "68 ?? ?? ?? ?? FF E7",

            # .text:00425A13 68 39 5A 42 00                                push    offset loc_425A39
            # .text:00425A18 FF 20                                         jmp     dword ptr [eax]
            "68 ?? ?? ?? ?? FF 20",
            "68 ?? ?? ?? ?? FF 21",
            "68 ?? ?? ?? ?? FF 22",
            "68 ?? ?? ?? ?? FF 23",
            "68 ?? ?? ?? ?? FF 24",
            "68 ?? ?? ?? ?? FF 25",
            "68 ?? ?? ?? ?? FF 26",
            "68 ?? ?? ?? ?? FF 27",
        ],
        resolve_calls_through_register
    ),
    (
        [
            # .text:0041CBB5 83 C4 04                                      add     esp, 4
            # .text:0041CBB8 FF 64 24 FC                                   jmp     dword ptr [esp-4]
            "83 C4 04 FF 64 24 FC",

            # .text:004239E3 44                                            inc     esp
            # .text:004239E4 44                                            inc     esp
            # .text:004239E5 44                                            inc     esp
            # .text:004239E6 44                                            inc     esp
            # .text:004239E7 FF 64 24 FC                                   jmp     dword ptr [esp-4]
            "44 44 44 44 FF 64 24 FC"
        ],
        deobfuscate_rets
    )
]


def patch():
    for patterns, patch_function in PATCH_DATA:
        anything_patched = True

        while anything_patched:
            anything_patched = False

            for pattern in patterns:
                ea = -_pattern_len(pattern)

                while True:
                    ea += _pattern_len(pattern)
                    ea = idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN | idc.SEARCH_CASE, pattern)
                    if ea == ida_idaapi.BADADDR or idc.get_segm_name(ea) != '.text':
                        break

                    patched = bool(patch_function(ea))
                    anything_patched |= patched

                    if patched:
                        print('[0x%08X] Code patched (%s)' % (ea, patch_function.__name__))

    print('[PATCHING FINISHED]')


patch()
