# Maze Ransomware
Malware actors used custom obfuscator to complicate the analysis (redundant code, jumps to the middle of instructions, conditional jumps etc.). In addition, anti-debug and anti-analysis checks are implemented, such as `PEB.BeingDebugged` flag check and terminating processes related to malware analysis (`x64dbg.exe`, `ida.exe` etc.). `maze-deobfuscation-idapython.py` script can be used for deobfuscation using IDAPython (tested on IDA 7.5).
Windows API addresses are resolved in a runtime by looking for needed API function by its hash calculated using custom algorithm. Malware sample contains `seed` value used in API hash calculations. Thus, included `maze-api-hash-generate.py` script might not be relevant for you if the seed value in your sample is different. The list of API hashes generated for `0x29A` seed can be found in `api-hash-generated-seed-0x29A.txt` file.
Besides file encryption Maze also acts like a Stealer. It seems like stolen data can worth much more than the ransom malware authors extorts for the file decryption. Collected data is sent to CnC servers which addresses are hardcoded into the configuration.
## Configuration
The configuration is stored encrypted by ChaCha8 algorithm and compressed. ChaCha8 key and nonce (IV) is crafted in a runtime. Nonce (8 byte) is simply built on stack, while the key is made using virtual-machine-like algorithm with hardcoded instructions set. The example of decrypted and unpacked configuration can be found in the `config-decrypted-decompressed.bin` file.
## Encryption process
Files are encrypted by ChaCha and RSA algorithms. RSA public key is stored in the config along with the ransom note.
